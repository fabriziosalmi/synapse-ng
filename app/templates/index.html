<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Synapse-NG Node</title>
    <script>
        // Inietta l'ID del nodo locale in una variabile globale JS
        window.LOCAL_NODE_ID = "{{ node_id }}";
    </script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <style>
        body { margin: 0; background: #0a0a0a; color: #fff; font-family: 'Courier New', monospace; overflow: hidden; }
        .panel { position: absolute; background: rgba(0, 0, 0, 0.85); padding: 15px 20px; border: 2px solid #444; border-radius: 8px; z-index: 100; font-size: 12px; line-height: 1.6; color: #aaa; }
        .panel strong { color: #00ff88; font-size: 14px; letter-spacing: 1px; }
        #info { top: 20px; left: 20px; border-color: #00ff88; box-shadow: 0 0 20px rgba(0, 255, 136, 0.3); }
        #topology-info { bottom: 20px; right: 20px; width: 280px; }
        #controls { top: 20px; right: 20px; }
        #canvas-container { width: 100vw; height: 100vh; position: fixed; top: 0; left: 0; }
    </style>
</head>
<body>
    <div id="info" class="panel">
        <div><strong>Synapse-NG Node</strong></div>
        <div id="node-id" style="margin: 8px 0;">ID: ...</div>
        <div id="node-count">Nodi Attivi: 0</div>
    </div>

    <div id="topology-info" class="panel">
        <strong>Analisi di Rete</strong><br><br>
        <div id="topology-content">In attesa di dati...</div>
    </div>

    <div id="controls" class="panel">
        <strong>Controlli 3D</strong><br><br>
        üñ±Ô∏è Rotazione: Drag sinistro<br>
        üîç Zoom: Scroll mouse<br>
        ‚ÜîÔ∏è Pan: Drag destro
    </div>

    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        const nodeMeshes = {};
        const linkLines = [];
        const labelSprites = {};

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);
            scene.fog = new THREE.Fog(0x0a0a0a, 600, 2500);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);
            camera.position.set(0, 200, 700);

            const container = document.getElementById('canvas-container');
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.minDistance = 100;
            controls.maxDistance = 1800;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(100, 200, 100);
            scene.add(directionalLight);

            const gridHelper = new THREE.GridHelper(1500, 30, 0x00ff88, 0x333333);
            gridHelper.position.y = -200;
            scene.add(gridHelper);

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            Object.values(labelSprites).forEach(sprite => sprite.quaternion.copy(camera.quaternion));
            renderer.render(scene, camera);
        }

        function createTextSprite(text, color = '#ffffff', fontSize = 32) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256; canvas.height = 128;
            context.fillStyle = color;
            context.font = `Bold ${fontSize}px Courier New`;
            context.textAlign = 'center';
            context.fillText(text, 128, 64);
            const texture = new THREE.CanvasTexture(canvas);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: texture }));
            sprite.scale.set(100, 50, 1);
            return sprite;
        }

        function updateGraph(nodes, links) {
            const allNodeIds = nodes.map(n => n.id);

            Object.keys(nodeMeshes).forEach(id => {
                if (!allNodeIds.includes(id)) {
                    scene.remove(nodeMeshes[id]);
                    delete nodeMeshes[id];
                    delete labelSprites[id];
                }
            });

            linkLines.forEach(line => scene.remove(line));
            linkLines.length = 0;

            const nodeMap = {};
            nodes.forEach((node, i) => {
                let sphere = nodeMeshes[node.id];
                if (!sphere) {
                    const geometry = new THREE.SphereGeometry(15, 32, 32);
                    const material = new THREE.MeshPhongMaterial({ color: 0x00ff88, emissive: 0x00ff88, emissiveIntensity: 0.2, shininess: 100 });
                    sphere = new THREE.Mesh(geometry, material);

                    const angle = (i / nodes.length) * Math.PI * 2;
                    const radius = 350;
                    sphere.position.set(Math.cos(angle) * radius, 0, Math.sin(angle) * radius);

                    const idLabel = createTextSprite(node.id.substring(0, 8));
                    idLabel.position.set(0, 35, 0);
                    sphere.add(idLabel);
                    labelSprites[node.id] = idLabel;

                    scene.add(sphere);
                    nodeMeshes[node.id] = sphere;
                }

                // Colora il nodo locale di un colore diverso per identificarlo
                if (node.id === window.LOCAL_NODE_ID) {
                    sphere.material.color.setHex(0xffffff); // Bianco
                    sphere.material.emissive.setHex(0xffffff);
                } else {
                    sphere.material.color.setHex(0x00ff88); // Verde
                    sphere.material.emissive.setHex(0x00ff88);
                }

                // Mappa la reputazione all'altezza (asse Y)
                const targetY = -150 + Math.min(node.reputation * 5, 400);
                sphere.position.y += (targetY - sphere.position.y) * 0.05;

                nodeMap[node.id] = sphere.position;
            });

            links.forEach(link => {
                if (nodeMap[link.source] && nodeMap[link.target]) {
                    const geometry = new THREE.BufferGeometry().setFromPoints([nodeMap[link.source], nodeMap[link.target]]);
                    const material = new THREE.LineBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.3 });
                    const line = new THREE.Line(geometry, material);
                    scene.add(line);
                    linkLines.push(line);
                }
            });
        }

        function analyzeTopology(networkState) {
            const globalChannel = networkState.global || { nodes: {} };
            const nodeCount = Object.keys(globalChannel.nodes).length;
            document.getElementById("node-count").textContent = `Nodi Attivi: ${nodeCount}`;

            let analysisHtml = ``;
            for (const channelId in networkState) {
                if (channelId === 'global') continue;
                const channel = networkState[channelId];
                const participants = channel.participants?.length || 0;
                const tasks = channel.tasks ? Object.keys(channel.tasks).length : 0;
                analysisHtml += `‚Ä¢ <strong>${channelId}:</strong> ${participants} part., ${tasks} task<br>`;
            }
            document.getElementById('topology-content').innerHTML = analysisHtml || "Nessun canale tematico attivo.";
        }

        init();

        // Imposta l'ID del nodo locale nel pannello info
        if (window.LOCAL_NODE_ID) {
            document.getElementById("node-id").textContent = `ID: ${window.LOCAL_NODE_ID.substring(0, 8)}`;
        }

        const ws = new WebSocket(`ws://${window.location.host}/ws`);
        ws.onmessage = (event) => {
            const networkState = JSON.parse(event.data);

            const nodes = networkState.global ? Object.values(networkState.global.nodes) : [];
            if (nodes.length === 0) return;

            const links = [];
            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    links.push({ source: nodes[i].id, target: nodes[j].id });
                }
            }

            updateGraph(nodes, links);
            analyzeTopology(networkState);
        };
    </script>
</body>
</html>
